Ansible:


ansible.cfg:
	может быть определён в 4х местах
	указываем нужен ли vault
	указываем от какого пользователя будем запускать playbooks (root)
	можно отключить проверку fingerprint (yes,no)

requirements.yml:
	посмотреть зависимости.
	тут можно найти ссылки  на github.com
    тут нужно проверять есть ли у нас сторонние зависимости.
    если у зависимостей есть внутр. зависимости. то они будут скачены автоматически.
    
 Для скачивания репозитория:
    # ansible-galaxy install -r requirements.yml 
   
Inventory:
    отвечает за группировку и разделение хостов
    может быть несколько файлов
    можно делать подгруппы (вложенность):children
    можно писать .ini .yml .json
    можно добавлять переменные [all:vars] [db:vars]
    тут же можно указать пользователя под который мы подключаемся и указывает ключ ssh(private)
    

Playbooks:
    связка ролей ролей и хостов на которых они исполняются
    может лежать где угодно
    gather_facts: no (сбор исходных данных о хосте при подключении)
    import = все переменные определены заранее 
    include = переменные могут быть определены в процессе исполнения
    
Антипаттерны:
    Стараться не использовать shell/command/raw без необходимости.
        Эти команды не имеют иденпотентности. Мы не знаем выполнилась ли успешно команда или была ошибка.
    Только в том случае если нет модулей.
    Не вызывать модули из консоли. Стараться выполнять из playbooks.
        например #absible all -m command -a "mkdir /opt" 
    Соблюдайте структуру файлов. Чтобы было удобно работать и другим.
    
====================
Управление целевым состояние окружения:
    настройка ОС
    установка и настройка системных пакетов и библиотек 
    управление конфигурациями
    настройка безопасности 
    можно обновлять например докер и библиотеки 
    
Templates:
    параметризованные файлы конфигурации
    возможность использования условий и переменных 
    возможность переиспользования конфигураций
    описываются при помощи шаблонизатора Jinja2 
    
Handlers:
    позволяют исполнять действия если task завершился со статусом CHANGED
      например перезагрузка сервиса если изменилась конфигурация
    вызывается через notify
    выполняется только 1 раз в конце выполнения play
    на один handlers могут ссылаться несколько задач
    задача-handlers может вызываться по нескольким событиям (через listen)
    handlers выглядет ровно так же как task
    сами хэндлеры лежат в директории handlers
    принудительное выполнение возможно при помощи модуля meta (не зависит от Changed)
        meta: flush_handlers
    иногда используется для бедных (когда мы выполняется хэндлеры в зависимости от параметров register:)
    
Dynamic Inventory:
    позволяет работать с инвентори полученным из внешних сервисов (в стоке статика руками)
    например через виртуализацию или API cloud мы можем хосты подгружать к себе динамически
    решает проблему дублирования и отслеживания хостов
    можно использовать и динамику и статику. Мы просто указываем путь до папки.
        #ansible-playbook -i path/to/inventories main.yml 
    иногда можно получать информацию после запуска терраформ. Забирать IP и складировать в файлик для ansible.
    
Ansible Vault. Шифрование:
    консольная утилита для работы с секретными данными (сертификаты, приватные ключ и т.д)
    переменные можно подключать через vars_files
    для более сложных случаев используется Hashicorp Vault или аналоги (централизованное хранение секретов)
        в стоке хранение в зашифрованном виде в репозитории
    позволяет хранить в общих репозиториях файлы, в которых содержится приватная информация (пароли, токены)
    использование зашифрованных переменных полностью прозрачно. В процессе выполнение ansible получает к ним доступ
    Файлы на диске остаются зашифрованными.
    например пароль для БД
    vars_files:
        - secrets.yml (импорт файла с секретами)
    мы можем зашифровать файл целиком:
        для шифрования нам нужен пароль.
        мы можем указывать ключик при запуске
        можем указывать файл в config.cfg (var_password_file = pass). Можно хранить локально или в гит папке но с gitignore.
            зашифровать: ansible-vault encrypt secrets.yml  (в нём лежат пароли)
                или
                #ansible-vault - vault-id dev@prompt encrypt --encrypt-vault-id dev secrets.yml
            изменить: #ansible-vault edit secrets.yml
            расшифровать: #ansible-vault decrypt secrets.yml
                или 
                        #ansible-playbook myplabook.yml --ask-vault-pass 
    можем зашифровать отдельные значения:
        #ansible-vault encrypt_string 'rootpasswd' --name mysql_root_password
            выдаст в консоль зашифрованный текст - его просто берём и вставляем в файлик вместо нашео пароля
                mysql_root_password: !vault |
                будут видны названия переменных - а сами значения зашифрованы

Include_* import_*:
    мы можем писать всё в main.yml. Но если таски большие и сложные. Можно писать отдельные файлы и импортировать их.
    import - обрабатывается перед исполнение playbooks. Ругается на неопределённые переменные.
        when - применяется на все вложенные задачи
    include - в процессе исполнения playbooks
        ansible -i inventories/development/hosts db(группа) -m setup (модуль)
        when - применяется только на задачу include_*       
    можно использовать и include_tasks и import_tasks в handlers, но есть нюанс
    можно делать deligate_to
        когда у нас в закрытой сети есть 1 хост который может выполнять действия над другими хостасми. 
        мы можем подключить к нему и заставить сделать команды с него
    
Tags:
    позволяет нам ограничить запуск тасков (хотим ли мы только установить или только читать и т.п.)
    мы указываем метки в плейбуках
    для каждого сценария и задачи может быть установлен более одной метки
    метки можно использовать для запуска определённых этапов сценария (--tags)
    можно пропускать части сценария по меткам (ключ --skip-tags)
   Запуск определённых сценариев:
    #ansible-playbook mytask.yml --tags "app_packages, deploy"
   Пропускаем Deploy:
    #ansible-playbook mytask.yml --skip-tags "deploy"
   Tag always - игнорирует ключ --skip-tags. 
   Tag never - таск не будет выполняется без задания --tags
   Несколько значений ключа --tags имеют логику ИЛИ 
   
Поиск ошибок:
    -vvvv
    -vvv
    -vv
    -v
    Пошаговое выполнение (диалог с вопросами ок не ок) ansible-playbook test.yml --step
    ansible-console (выполнение в интерактивном режиме тасков) ansible-console -l balancer
    модуль debug (выводит переменные) (debug: var: test_var)
    debugger strategy plugin - новая реализация стратегии (отладочная информация)
    можно запустить playbook с конкретного таска (--start-at-task NAME)
    пример:
        #ansible -m ping localhost -vvvv
    
Лекция 3:
    план:
        Организация инфраструктурного кода 
        Роли в Ansible 
        Работа с окружениями
        
    Playbooks
 плюсы  -просто читать и писать 
        -просто отлаживать
 минусы
        -быстро разрастаются в размере
        -быстро расрастаются в кол-ве  
    Когда у нас dev/test/stage/prod раскатывается. Нужно учитывать что куда и чего раскатить
    Когда у нас нужно поменять что то мелко в проде - нам нужно не забыть потом перекинуть в stage
    Короче нужно версионирование
    Не подходят как формат для распространения и переиспользование кода 
        -нет версии 
        - нет зависимостей и метаданных
    Роли:
        это директория с определённой структурой и YAML-файлами
        Роль содержит:
            -tasks, handlers
            -наборы переменных 
            -метаданные (версии и зависимости от других ролей)
            -тесты (для локальной отладки и разработки)
            -вспомогательные файлы и шаблоны
        Создание роли (шаблона):
            ansible-galaxy init $NAME
        Если роли нет в папке локально, а она указана в playbooks, то ansible сходит за ней в galaxy.
        Неплохая практика когда мы в requirements.yml указывам src и конкретную версию 
            если скачать самую новую (latest) то она может быть изменённой и не сработает у вас как х
            работала до этого.
    Версионирование ролей:
        #ansible.cfg > roles_path = $PATH
        можно хранить в своей репе - но будут проблемы при обновлении сторонних ролей
        можно сделать по репозиторию в гит для каждой роли (редко когда так делают)
        
 Окружения в Ansible:
    Нет понятия окружения (dev, stage, prod). 
        -есть группы хостов 
        Типичное описание окружения состоит из: 
            -списка серверов и их групп 
            -средозависимых данных (переменные и файлы)
            -списка ролей и их версий, актуальных для окружения
    Структура:
        -environments
            -dev 
                -group_vars
                    -webservers
                    -databases
                -requirements.yml
                -credentials.yml
                -inventory
    Получаем необходимый набор ролей:
        #ansible-galaxy install -r environments/env_name/requirements.yml
    Запускаем плейбук, который вызывает эти роли:
        #ansible-playbook -i environments/env_name/inventory play.yml
    
    Можно сделать группу inventories (а в ней уже группы по средам)
    config.cfg:
        [diff]
        always = True 
        context = 5 
            показывает какие строчки поменялись в конфиге

Хранение инфраструктурного кода:
    -можно хранить код в репозитории вместе с кодом продукта
        но там вопросы разграничения доступа с разработчиками. могут они чё то подшаманить
    -можно хранить в выделенном инфраструктурном репозитории 
        -удобно вести разные версии для разных окружений
        -выделенной команде Ops проще вносить изменения
    
Повышение привилегий:
    директивы 
        -become (привилегированный режим - выполнение от рута)
        -become_user
    Можно указывать:
        -глобально
        -на плейбук
        -на каждый таск (блоки и т.п.)
    Пишите плейбуки и роли так, чтобы действия, которым нужен root были явно выделены!
    
Пространства имён переменных:
    писать переменную которая описывает свое назначение и принадлежность к роли
        http_port: 8080 #неправильно
        show_backend_http_port: 8080 #правильно
    По хорошему, название переменной = должно начинаться с названия роли!
    Ansible загружает все файлы в group_vars для хоста
        даже если группа в плейбуке не учавствует в сценарии
        это может привести к неоднозначности значений переменных 
    Нужно использовать префиксы в именах переменных.
    
Запись 4:
    План:
        тестирование инфраструктурного кода 
        инструменты и примеры
        практики из разработки
        
    А зачем нам нужно тестировать код?
       - улучшаем и контролируем качество 
       - получаем обратную связь
       - экономим время за счёт автоматизации
       - тесты как документация
       например:
       - правильно ли всё поставилось. Все ли порты на месте. Все ли конфиги создались и т.п.
    Когда актуально:
        - много изменений (динамика)
        - коллектив (текучка и т.п.)
        - сложная логика (когда не всегда понятно а что должно быть на выходе) 
        - чужой код
     "Разработка через тестирование!"
     
     Изменение могут быть:
        -внутренние (релизы, инциденты, смена стека и т.п.)
        -внешние (новая версия роли, новая версия пакета, новая версия OS)
        
    Страх автоматизации. Я запущу плейбук и он всё сломает!!!1
    
    Из официальной документации:
        - Ansible: fail-fast, order-based, declarative...(
        - dry run (--check) = посмотреть что поменяется. Работает так себе.
        - Модули uri(доступность по коду 200 и парсинг сайта), script (попробовать подключиться)
            , assert (условия для проверки, проверка памяти например), 
            stat (наппример права доступа на файлах проверить)
        - Rolling update (обновлять постепенно) и pre-/post-tasks (старая версия)
    Что мы можем тестировать:
        -стиль языка и инфраструктурного кода
        -валидация кода
        -функционал (интеграцию и результата работы)
    На основе Style Guides и Best Pracrtices 
    Линтеры для языка Python:
        pep8
    Линтеры для инфраструктурного кода Ansible:
        yamllint, ansible-lint (около 20 правил)
            конфигурация в .snsible-lint (есть в Ansible Galaxy)
            допустим мы делаем хуки при пуше в git (чтобы проверял до записили)
            есть интеграции в IDE и GIT 
     
    Какие типы тестирования в ИТ есть?:
        -Unix
        -Интегретион
        -Smoke (проверка только основных кейсов)
        -пентесты
        -нагрузочное
        Есть пирамида тестирования 
        
        Основа = Unit tests = модульное тестирование = базовая 
            = проверка функций в коде насколько они корректно отрабатывают 
        Выше = Integration tests = проверка в связке с другими сервисами (например БД или идёт в другой 
            сервис и т.п. Связки.
        Выше = Acceptance tests = приёмочное тестирование = бизнес-логика 
        Выше = manual tests = как конечный пользователь = насколько всё работает хорошо
        
    Инфраструктурные тестовые фреймворки:
        проверяем состояние инфрастрктуры - локальных или удалённых окружений 
        наиболее популярные: Serverspec, inSpec, Testinfra, Goss
        
    В ручном режиме это было бы так:
        Мы локально прогоняем линтеры 
        Запускаем ВМ 
        Запускаем Ansible
        Смотрим diff изменений 
        Запускаем инфраструктурные тесты 
        Проверяем результаты 
        Удалём виртуалку
    Это можно автоматизировать:
        Vagrant (не все этапы)
        Test Kitchen
        Molecule (Ansible)
        Breaker (Puppet)
        
    Vagrant:
        инструмент для автоматизации разработки
            -создание,настройка и удаление локальных окружений
            -Providers (VirtualBOx, Hyper-V, Vmware, Docker...)
            -Provisioners (Ansible, Chef,Puppt,Salt, Shell...)
            -Плагины
            
    Molecule (ansible)
        #molecule init role --role-name db --driver-name vagrant
    Для готовой роли:
        #molecule init scenario --scenario-name default -r db -d vagrant
    Файл конфигурации: molecule.yml 
    #molecule create (создаёт виртуалку и т.п.)
    #molecule converge (накатывает playbook)
    #molecule verify (прогоняет тесты)
    #molecule idenpotent (прогоняет плейбук повторно и мы смотрим есть ли изменения)
    #molecule test (запускам весь pipeline) 
    
    Молекула не замена Jenkins, Bamboo, GitLab Ci...
    
    Примеры Pipeline:
        -для Ansible роли
        -для инфраструктурного репозитория
        -для внешних зависимостей 
        -для сборки образов 
        -для создания окружения
    
    
    
Вопросы:
    для devpoint есть ли запрет на хранение информации и запуск. Например для хранения приватных ключей.
    если удалить ключ - чё делаем?
    выделенный контур с управленеим - deligate_to 
    посмотерть что такое set_fact
    скачиваем ли мы роли с galaxy. Есть ли там уязвимости. Как проверяем.
    если роли нет в папке локально, а она указана в playbooks, то ansible сходит за ней в galaxy.
    по хорошему надо забирать к себе в репозиторий роль и запускать от себя 
        если в гитхабе её не будет, а мы от неё зависимы. Будем сосать лапу.
    отдельно можно создавать в окружении файлик где мы будет хранить сентсетив данные переменные
        которые мы потом зашифруем
        там же его можно будет закинуть сразу в .gitignore
    в config.cfg есть раздел по [ssh_connection] надо посмотреть настройки например 
        ssh_args=-o ForwardAgent=yes 
    а что если переменные наш нужны разные на уровне разных сред и проектов. Например 
        разные ключи и креды для разных сред разработки. Как быть?
    есть ли у нас локальный Galaxy?
    храним ли мы роли в артефактори? Единый реестр.
    Прогоняем ли мы наш код в QA? Pre-prod? > Prod окружении?
    