Технологии контейнеризации Docker
1 занятие:

Виртуализация - программная имитация аппаратного обеспечения

Программная виртуализация:
	-динамическая трансляция (Virtual Box)
	-паравиртуализация (Xen)
Аппаратная виртуализация (KVM, Xen, VMware, Hyper-V)

Контейнеризация (LXC, OpenVZ, Jail, Zones) - виртуализация на уровне ОС.
	в пространстве ядра и тех же процессов.
	по сути можно было ограничивать процессную мощность и т.п.
	LXC - можно было изолировать приложение. Был до докер. 
	Везде на сервере одна ОС - один и тот же ресурс. Происходит виртуализация на уровне ОС.
	
#Как работает Docker:
	-Namespaces = способ изоляции ресурсов ядра
	-Cgroups = изоляция память и CPU 
	-UnionFS 
	-RunC
	
#Namespaces 
	Изоляция окружения. Каждый контейнер - уникальная единица.
	Каждый контейнер работат со своим namespaces
		-pid: Изоляция  процессов
		-net: Изоляция сетей
		-ipc: Изоляция IPC
		-mnt: Изоляция файловой системы (смонтированные диски)
		-uts: Изоляция Unix Timesharing System (время)
		-user: Изоляция пользователя (вплоть до ID)
	Namespace закрывается, если PID 1 умер.
	
#Conrol groups
	Позволяет контейнерам использовать общие ресурсы
	Ограничивает набор доступных ресурсов
	ЦПУ, память, IO....
	Используется редко, разграничение делается когда контейнеры начинают друг другу мешать.
	Фишка ядра линукс.
	
#Union File Systems:
	Разделение по слоям
	Переиспользование слоёв
	Когда мы создаём контейнер, контейнер состоит из многих слоёв. Каждое изменение это слой.
	
#RunC 
	Библиотека-обёрка над Namespaces, cgroups, UnionFS позволяющие нам запускать контейнеры.
	
	LXC,OpenVZ = Namespaces + Cgroups. Не было UFS, ресурсы выделялись заранее и монтировались как диск.

#Из чего состоит Docker :
	-daemon (запускает из образов контейнеров и управляет ими). Предоставляем API.
	-client (отправляет команды на daemon, принимает команды пользователя)
	-registry (хранилище артефактов, docker hub, private registery, docker trusted registery, docker store)
		store = локально на АРМ (перенос с флешки)
	
В OSx и Windows нет ядра linux, поэтому он запускается тут иначе.
	поднимается DOCKER_HOST(c ядром Linux) это виртуалка. А в нём уже Docker daemon.
	
По сути контейнер как объект = это процесс.

#Docker images 
	image = неизменная сущность snapshot контейнера
	image состоит из слоев (layers)
	layers - read-only diff изменений файловой системы
	
#Безопасность:
	docker - это всего лишь тонка прослойка
	-Привилегии пользователей ограничены Whiteлистом
	-Можно включить user-namespace (не всегд возможно). Отключает у рута в контейнеры полномочия для блокчных устройств хоста например.
	-Не запускайте приложения от root 
	-Надо заниматься патч-менеджментом (обновлять ровно так же как и хостами).
	-Не использовать передачу паролей и прочих секретов через ENV-переменные  (ну вообще это в целом норм).
		прикол в том что если в соседнем контейнере получили доступ к каталогу /proc - то можно посмотреть переменные и секреты

Достаточно вообще возможностей пошатать в системе что-то через докер даже без уязвимостей.
	Например у пользователя доступен dd и пользователь может перезаписать/записать всё на диск (интересно как)
	есть доступ к /prot (по дефолту)
	Есть способы ограничения (capabilites). Настраивается в процессе запуска.
	
	68% разработчиков сам отвечают за безопсность контейнеров 
	50% не сканируют ОС в docker image 
	45% никогда не находят новы уязвимости в их контейнерах 
	80% не тестируют свой Docker images во время разработки
	
Как улучшить безопаность:
	Правильный выбор base image 
		-используем минимальный image, не упаковывате то, что вам не нужно!
		есть distraless подход, при котором в образе нет ничего, кроме того что мы туда положим.
		совсем маленькие имиджи не удобны для отладки по началу. Это выше уровень зрелости.
	Использование multi-stage сборок
		можно собирать несколько пакетов и кладём в пустой контейнер (оО)
	Пересборка images 
		-при пересборке образов используйте --no-cache
			-если мы его не отключаем, то обновления работать не будут оО 
	Сканирование images на стадии development 
	Сканирование контейнеров в production
	
	10 Docker image Security Best Practice (link)
	
Dockerfil
	FORM (указываем базовый слой)
	
	RUN (каждая команда создаёт новый слой)
	RUN ...
		Каждая команда кэшируется, если ран сделался 1 раз, то второй раз собираться не будет (Оо0
	COPY (положить что-то из локального в контейнер)
	
	$docker run -it -p 80:80 kong/httpbin
		-it = вывод информации на консоль
	$docker ps 
	$docker ps -a 
	$docker exec -it $IMAGE /bin/bash 
		подключаемся 
	$docker kill $IMAGE
	$docker inspect $IMAGE
		когда контейнер запушен
		какие команды были при запуске 
		порты сетевые 
		ограничение процессора и памяти 
		MaskedPaths (пути которые мы не прокидываем внутрь нашего контейнера)
		и т..п 
	$docker images (наши образы)
	
	После установки docker на линукс, по дефолту работает докер от рута. От обычно пользователя нельзя.
	Если нам не нрав работать от рута то меняем права 
		$sudo gpasswd -a vagrant docker 
	
	cd /proc/4662/
	cat environ 
		с хоста можно посмотреть переменные контейнера. (под рутом)
		
Видео № 2

	1. Работа с Dockerfile 
	2. Работа с данными в docker 
	3. Работа с сетью в docker 
	4. LIve по сети и docker-compose
	
	Dockerfile - набор инструкции
		Dockerfile > build > image > RUN > Docker container
	
	Example
	FROM alpine (какой образ мы берём базовым)
	RUN apk add \
		python3 \ 
		py-pip \
		&& pip install virtualenv \
		&& rm -rf /var/cache/apk/*
	
	Более правильный вариант с 1 RUN.
	Всё запишется в один слой
	
Storage driver:
		Docker использует драйверы хранилища для хранения слоев изображений 
		и хранения данных в доступном для записи  уровне контейнера
	$docker info 
		storage driver: overlay2
			backing filesystem: extfs
		
Какие файлы стоит хранить постоянно?
	-конфигурационные файлы 
	-скачиваемые для использования плагины 
	-базы данных 
	-настройки пользователей 
	-артефакты работы приложения 
	-скрипты которые мы используем 
	
Docker volumes используются для:
	-данных с интенсивной записью
	-данных которые должны храниться по истечении срока жизни контейнера 
	-данных которые должны совместно использоваться контейнерами
	
	у облачных провайдеров подключаются S3. 
	тома можно шифровать 
	тома можно наделять данных заблоговременно
	
	По умолчанию 
		/var/lib/docker/volumes/ (в линукс) 
	Важно! Другие программы не должны получать к ним доступ напрямую, только через контейнер
		типо не безопасно
	
	Host:
	$docker run -v /home/mount/data:/var/lib/mysql/data
		-v = volume
	
	Anonymous:
	$docker run -v /var/lib/mysql/data 
	если том анонимный, его можно удалить сразу после завершения работы контейнера
	при удалении контейнера - сразу удалиться и том (--rm -v)
	
	Named volumes:
	$docker run -v name:/var/lib/mysql/data 
	чтобы проще ориентироваться в FS.
	
Docker-Compose 
	обычный докер применяется 1 приложения 
	docker-compose применяется для управления несколькими приложениями
	более быстрее 
	он автоматизирует работу с докер
	декларативно = мы говорим машине какой финальный результат и он делает
	рекомендуется хранить переменные не в docker-compose, а в файле локально 
		env_file: ./.env 
	$docker-compose up -d #запуск 	
	$docker-compose down #убить все контейнеры 
 	
Работа с сетью в Docker 
	-настройка правил iptables (linux)
	-управление правилами маршрутизации (win)
	-формиование пакетов и их инкапсуляция
	-шифрование
	-безопасность 
	
	Network Drivers:
		-bridge (default), - связи между контейнерами 
			общение может быть только внутри бриджа, между бриджами вроде нет 
		-host, - связь с хостом 
			драйвер удаляет сетевую изоляцию между контейнером и хостом Docker, и напряму использует сеть хоста 
			работает только на Linux
			проблемы - порт может быть занят хостом 
			конфликт ip адресов 
			какие то безопасные проблемы с изоляцией - толком не сказал ничего
		-overlay, - связь с 
			объединяет сети контейнеров на разных Docker хостах
			на Windows хостах нет шифрования!
		-macvlan, - получени физ мак адреса для каждого контейнера 
			не работает с компоуз
			работает только на linux 
		-none, - не было доступа к сети 
		-network plugins
			vxvlan, ipvlan, macvlan и другие

Для мониторинга контейнеров не юзают прометей, в основном берут мониторинг с оркестраторов

Видео 3.
Docker образы. Микросервисы.

	основы написания Dockerfile 
	готовим правильно 
	базовые образы 
	микросервисы
	
	Dockerfile:
		-текстовый файл с последовательным описанием инструкций для сборки образа 
		-каждая инструкция создаём промежуточный слой образа 
		-сам сборку делает демон Docker, а не Docker CLI
	
	Инструкции:
	$FROM - какой образ будет базовый
	$FROM quay.io/vektorlab/ctop #указываем свой путь до образов 
	$LABEL: задаём метаданные для нашего образа (почту - версию образа и т.п. редкие)
	$COPY: копируем файлы из контекста в образ. Вроде можно устанавливать права доступа.
	$ADD (не рекомендуется). Похоже на копи (для файлов одно и тоже) 
		может скачивать файлы из интернета 
			ADD http://exmaple.org/app.tar.xz /src/app/	
	$ENV задаёт переменные окружения при сборке 
		переменные в начале сборки будут с нами до конца сборки
	$WORKDIR 
		задаём рабочую директорию при сборке (аля DIR)
		$RUN mkdir /app 
		$WORKDIR /app 
		тоже самое что и cd, но эта инструкция задаёт новый слой образа
	$VOLUME: позволяет указать точки для монтирования томов внутри образа (например логи)
	$EXPOSE: указывать порты, которые слушает сервис в запущенном контейнере 
		$EXPOSE 5000/tcp 3389/tcp 
		но это команда не заменяется -p docker run. И публиковаться не будут порты без run 
		команда нужна для документации человека
		так же внутри кубера помогает как доп информация (вроде) 
	$RUN: задаёт команды которые выполняются при сборке контейнера
	$CMD: задаёт команду которая выполняется при Старте контейнера
		команда уже после сборки.
		CMD может быть только одна
	$ENTRYPOINT: команда которая выполняется при старте контейнера
		по дефоту не задан
		
Dockerfile Reference 
	$ONBUILD - задает команду которая запускается при сборке образа на базе текущего
	$STOPSIGNAL - сигнал который посылается процессу при остановке контейнера 
	$USER - ID пользователя от которого выполняются директивы RUN, CMD, ENTRYPOINT 
		этот пользователь хорошо запускать для приложения
		от этого пользователя будут последующие команды 
		этот пользователь будет так же на последнем слое 
	$ARG - почти как ENV, но задаёт параметры только для docker build 
	$HEALTCHECK - указывает команду которой можно проверить состояние сервиса

Файл .dockerignore 
	
	
Вопросы
	посмотреть уязвимости докеров на старый легаси версиям - заполнить
	
	